#! https://zhuanlan.zhihu.com/p/669577047
# 【CUDA编程】#pargma unroll 指令

**写在前面**：截至发布上一篇文章，笔者已经两个多月没有写作。一方面是 4 季度工作实在太忙了，尤其临近年底，各种 KPI 指标要完成，周末也得工作；另一方面是笔者这段时间也在认真阅读 Nvidia 官方的 cuda 编程指南给自己充充电，英文文档的阅读过程实在困难又枯燥，但是市面上 GPU 编程相关的书籍又过于老旧，没办法，Nvidia 版本更新实在太快了！！！除了阅读之外笔者打算基于自己的理解把 CUDA C Programming Guide 翻译成中文，目前初稿已有 150 页左右，本文正是其中一小节，由于笔者水平有限，文章若有错漏之处，欢迎读者批评指正。

## 1 设备端循环语句的开销
通常在 CUDA 应用程序中，设备端也会使用大量的循环语句，对于一个典型的 `for` 循环来说，可以分成两部分：一是循环体，这是 `for` 循环中真正用来完成任务的部分；二是循环控制部分，也就是 `for` 后面的那行代码。循环控制部分的开销可以分为 $3$ 类：
- 一次性的开销，例如 `i=0` 初始化；
- 每次循环的控制开销，例如 `i<n` 判断；
- 每次循环后的操作，例如 `i++` 递增。

因此，在循环体之外，这些循环控制的开销很多时候不能无视，因为它们也将在 SM 上执行，占用计算资源。能否将这些额外的控制占用的成本降低到最小，则是取得性能提升的一个关键因素。

## 2 #pargma unroll 指令
针对已知循环次数的小循环语句，编译器通常会默认将循环展开。此外，还可以通过 `#pragma unroll` 指令控制任何给定的循环语句在编译时展开。该指令必须放在循环语句之前并且紧接着循环语句，仅对该循环适用。  

当一个循环的次数非常大时，往往不可能完全展开，例如有 $1000$ 次循环，展开后代码量可能超过设备上的代码缓存，所以 `#pragma unroll` 指令后面允许跟随一个整数常量表达式 ICE，此参数是可选的。例如，在指定 ICE 为 $20$ 的情况下，总循环次数 $1000$ 次，每 $20$ 次展开，这样从原本的 $1000$ 次循环，每次完成 $1$ 个任务，变成了循环 $50$ 次 $(1000/20=50)$，每次完成 $20$ 个任务，虽然不能完全展开，但控制成本变成了原本的$1/20$，同时编译器生成的目标代码体积，也只增加了 $20$ 倍，是一种不错的折中方法。  

假设 ICE 缺省，如果循环次数是个恒定值，则循环将完全展开；如果 ICE 计算结果为 $1$，编译器将不会展开循环；如果 ICE 计算结果为非正整数或大于 `int` 数据类型可表示的最大值的整数，则该 `#pragma unroll` 指令将被忽略。

示例代码如下：

```cuda
struct S1_t { static const int value = 4; };
template <int X, typename T2>
__device__ void foo(int *p1, int *p2) {

    // no argument specified, loop will be completely unrolled
    #pragma unroll
    for (int i = 0; i < 12; ++i)
        p1[i] += p2[i]*2;

    // unroll value = 8
    #pragma unroll (X+1)
    for (int i = 0; i < 12; ++i)
        p1[i] += p2[i]*4;

    // unroll value = 1, loop unrolling disabled
    #pragma unroll 1
    for (int i = 0; i < 12; ++i)
        p1[i] += p2[i]*8;

    // unroll value = 4
    #pragma unroll (T2::value)
    for (int i = 0; i < 12; ++i)
        p1[i] += p2[i]*16;
}


__global__ void bar(int *p1, int *p2) {
    foo<7, S1_t>(p1, p2);
}
```